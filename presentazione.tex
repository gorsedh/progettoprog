\documentclass[a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[main=italian, english]{babel}
\usepackage{graphicx}
\begin{document}
\title{Relazione Progetto Programmazione per la Fisica}
\author{Marco Caporale, Giacomo Giuliani}
\date{Settembre 2020}
\maketitle

\section{Introduzione}
Questa relazione ha lo scopo di illustrare lo sviluppo del progetto per l'esame di Programmazione della Fisica dell'Anno Accademico 2019/2020. \\ \\ Il progetto è composto da un programma in linguaggio C++ che simuli lo sviluppo di un'epidemia su una griglia di stati. Il modello di sviluppo associato è il cosiddetto $SIR$, nel quale gli stati di salute delle persone in esame hanno uno sviluppo naturale, inizialmente sono \underline{suscettibili} (S), quindi \underline{infetti} (I), infine \underline{rimossi} (R), categoria che comprende indifferentemente i soggetti guariti e i morti. \\ I passaggi da uno stato al successivo sono associati a due valori di probabilità, $\beta$, la probabilità di un suscettibile di essere infettato quando a contatto con un infetto e $\gamma$, la probabilità di un infetto di diventare un rimosso. \\ 

\section{Requisiti}
Il programma non richiede particolari requisiti, in particolare per le opzioni con stampa a terminale. \`E comunque necessario assicurarsi che siano disponibili i caratteri colorati per la stampa dal proprio terminale (UBUNTU/Linux e Mac Os), nel caso non venissero caricati è sufficiente chiudere e riaprire il terminale.\\
Le istruzioni compaiono a schermo.\\
Per eseguire l'analisi grafica dell'epidemia è necessario il software di analisi dati Root, disponibile su \texttt{root.cern}.
Al termine del programma verrà chiesto se salvare il report dell'epidemia come \textttt{report.txt}. Inserire questo file nella stessa directory di macro.c ed eseguirvi Root, chiamando prima \texttt{.L macro.c} e poi la funzione desiderata di stampa (opzioni disponibili elencate nella sottosezione Elaborazione dati e Grafica).

\section{Opzione 1}
Lo sviluppo del progetto è iniziato attraverso la stesura di una  bozza dell'opzione 1, ovvero una stesura molto approssimativa di un'evoluzione lineare della pandemia nel tempo - il codice di tale sviluppo non verrà consegnato con la relazione, ma verranno utilizzati i risultati di quest'ultimo come confronto teorico con il modello principale. 
Per tale modello, è stata definita una \texttt{struct State} che racchiude solo i 3 stati possibili,$S, I, R$, definiti come \texttt{int}, associata a questa, è stato definito un operatore di uguaglianza da poter utilizzare nella funzione di evoluzione \texttt{bool operator==(State const& lhs, State const& rhs) {
		if((lhs.s == rhs.s) && (lhs.i == rhs.i) && (lhs.r == rhs.r)) { return true;}
		else { return false;}
	}}. \\ \\ Quindi, viene definita minimalmente una \texttt{class Epidemic} utile a definire il decorso dell'epidemia, nella quale viene definita la funzione Evolve, che simula il decorso di S(t), I(t), R(t) sfruttando le equazioni del modello $SIR$ a partire da uno stato iniziale, \texttt{state s0}, definito nella parte \texttt{private}. \\ \\ Per quanto riguarda la funzione di stampa, viene implementata la funzione \texttt{void printData(std::vector<State> report) {}} che opera sia una stampa da terminale sia una raccolta dati su un file di testo, poi elaborati graficamente sul software root, elaborazione che sarà presentata in seguito come confronto con i risultati ottenuti dal modello successivamente presentato.  


\section{Opzione 2}
\subsection{Premessa}
La parte principale del progetto è stata dedicata al secondo progetto possibile, ovvero lo sviluppo di una simulazione epidemica attraverso una griglia di stati ispirata al celebre Game of Life di Conway;la differenza principale tra il G.O.L. e la simuazione epidemica risiede nell'evoluzione della board: se, infatti, nel primo caso lo sviluppo della board è definito tramite alcune semplici condizioni, nel secondo caso il processo dipende da 2 probabilità: $\beta$ quella di infettarsi e $\gamma$ quella di guarire se infetti, inserite a scelta dall'utente.\\ 
\subsection{Strutture}
Il cuore del progetto sono le due variabili $\beta$ e $\gamma$, dichiarate \textit{globali} per facilità di accesso delle altre funzioni del programma. Per questo motivo, è stato necessario implementare delle funzioni di controllo in modo tale che le variabili, quando modificate dalle funzioni  del programma, vengano ristabilite ai valori originali inseriti dall'utente.\\
Quindi è necessario definire una \texttt{enum Condition} che possa contenere i possibili stati di salute degli individui in esame, $S, I, R$ rispettivamente suscettibili, infetti, rimossi.\\
Questi vengono poi disposti nella \texttt{class Population} a formare il vettore che rappresenti la popolazione in esame. Alla classe sono stati aggiunti alcuni metodi necessari alle altre funzioni del programma, fra questi i metodi di conta dei determinati stati assunti dalle celle. Al metodo di conta dei suscettibili vengono rimossi i soggetti sul bordo della griglia, in quanto vengono definniti di defalt come suscettibili, perciò impossibilitati a modificare il proprio stato di salute.\\
La rappresentazione grafica del sistema avviene tramite stampa da terminale. Questa risulta efficiente con popolazioni di esigue dimensioni ma rischia di non esserlo per grandi misure della board. Per questo motivo i dati vengono raccolti in un vettore che li stampa su un file di testo \texttt{std::vector<dailyReport> finalReport} per l'elaborazione grafica tramite software Root. Per tale fine è stato aggiunto \texttt{struct dailyReport} che contiene i dati raccolti dai metodi di \texttt{Population} alla fine di ogni giornata.\\
\subsection{Epidemia}
Il fulcro del programma consiste nell'effettiva diffusione dell'epidemia lungo la griglia, motivo per cui sono necessarie le funzioni \texttt{adjacentInfects} e \texttt{spread}: la prima conta quanti infetti sono presenti nelle otto celle adiacenti a quella in esame, la seconda, invece, prende in input la precedente popolazione per poi evolverla nella successiva. Il processo di base avviene generando tramite \texttt{uniform real distribution} un numero casualmente distribuito fra 0 e 1. Tale numero viene poi confrontato per ogni cella $Suscettibile$ con la probabilità di contagio, ovvero $\beta$ moltiplicato per il numero di infetti adiacenti alla cella e qualora fosse minore lo stato della cella verrebbe aggiornato ad $Infetta$. Tale relazione nasce dal considerare la probabilità di infezione come la retta passante per i punti $(0;0)$ e (1;$\beta$) nel piano cartesiano. Per le celle $Infette$ invece il numero viene più semplicemente confrontato con il $\gamma$. La funzione \texttt{spread} è stata in seguito soppressa per lasciare spazio alle due funzioni \texttt{linearSpread} e \texttt{nonLinearSpread}.\\ \\ \texttt{linearSpread} viene proposta due versioni, la prima (Lineare 1), come versione pura di \texttt{spread}, la seconda (Lineare 2), invece, va a sostituire la retta di contagio precedentemente definita con la retta passante per (1;$\beta$) e (8,1).Onde evitare che il valore della probabilitàdi contagio possa essere maggiore di 1 per un valore nullo di \texttt{adjacentInfects} è stata introdotta la funzione \texttt{booleanMarker} che restituisce 0 quando le viene dato in input 0, altrimenti 1. Questo secondo modello è stato lasciato commentato nel codice dal momento che la sua versione più "grezza", la versione pura di \texttt{linearSpread}, produce risultati molto più vicini a quelli attesi del modello $SIR$.\\ \\
Il modello basato sulla funzione \texttt{nonLinearSpread} utilizzainvece un approcio differente, in primo luogo aggiungendo ai suoi parametri di input anche il tempo passato dall'inizio dell'epidemia \texttt{int daysPassed}, in questo modo, per determinati intervalli di tempo, si possono modificare le variabili $\beta$ e $\gamma$, poi ristabilite dalla funzione di controllo. Esempi applicativi presenti nel progetto sono: la simulazione delle maggiori relazioni interpersonali nei weekend \texttt{if (daysPassed \% 7 == 0) { beta = beta * 1.5; }}, per cui è lecito ipotizzare un aumento del tasso di contagio; inoltre, si è scelto di seguire un modello "svedese", senza quindi simulare eventuali misure particolarmente restrittive, come una quarantena, a favore di uno sviluppo di metodi curativi e un conseguente aumento del tasso di guarigione $\gamma$ - 
\texttt{$if(daysPassed>60&&daysPassed<=100){gamma_=gamma_*1.5;}
if(daysPassed>101){gamma_=gamma_*2;}$}. \\

\subsection{Inizializzazioni}
La prima scelta lasciata all'utente aprendo il programma è quale tipo di simulazione si voglia effettuare, piccole popolazioni con output grafico o grandi popolazioni senza output grafico da terminale; ognuna delle precedenti opzioni è associata ad una rispettiva funzione di esecuzione \texttt{execute} e alle rispettive inizializzazioni.\\
Il programma lascia una discreta libertà di scelta all'utente, in particolare per quanto riguarda le due variabili  $\beta$ e $\gamma$ e la dimensione della popolazione da prendere in esame, attraverso la scelta della grandezza della griglia. Per ognuno di questi parametri sono presenti una o più funzioni di inizializzazione; per quanto riguarda le simulazioni con output grafico la dimensione della popolazione è limitata poichè oltre una determinata soglia la stampa da terminale diventa disordinata e quindi inutile. Viceversa l'opzione per grandi popolazioni è limitata esclusivamente alle prestazioni del pc che esegue il programma, si possono infatti eseguire in tempi ragionevoli simulazioni anche su popolazioni dell'ordine del milione.\\
Sono inoltre presenti differenti inizializzazioni per il numero iniziale di infetti delle grandi popolazioni, in particolare la possibilità di partire da un solo infetto casualmente disposto nella griglia, 10 infetti disposti in una porzione ridotta di griglia o un numero di malati scelto dall'utente. Per le piccole popolazioni è stato scelto di lasciare un solo tipo di inizializzazione degli infetti ovvero quello di infettare solamente il soggetto in (1;1). Tale decisione dipende fondamentalmente da due motivi, il primo è l'alta improbabilità che più soggetti importino il morbo dall'esterno in una popolazione ridotta, la seconda invece è la maggior apprezzabilità dell'output grafico vedendo l'epidemia partire da un solo angolo per poter poi diffondersi lungo tutta la griglia. \\
\subsection{Elaborazione dati e Grafica}
L'output grafico con stampa a terminale del programma è disponibile solo per le piccole popolazioni tramite la funzione \texttt{gridPrint}. Ad ogni stato è associata una determinata lettera con un differente colore per facilitare la lettura durante la stampa. \\
Sia che si utilizzi l'output grafico del terminale o no alla fine dell'epidemia (ovvero quando il numero degli infetti scende a zero) il programma chiederà all'utente se vuole la stampa su file di testo (\texttt{.txt}) del report dell'epidemia, ovvero la conta giornaliera degli stati della popolazione. Tale report può essere graficato tramite l'uso del software di analisi dati Root. Assicurandosi che il file si trovi nella stessa directory da cui si esegue la macro è possibile stampare i grafici con i singoli andamenti di ognuno degli stati possibili (\texttt{graphS()}, \texttt{graphI()}, \texttt{graphD()}) oppure di stampa di tutti e tre gli andamenti su un unico grafico (\texttt{graphEpidemic()}). Utilizzando \texttt{graphAll()} si possono stampare tutti igrafici contemporaneamente.
\subsection{Estensione del modello $SIR$}
Terminata la "parte canonica" del progetto, il modello $SIR$ per includere anche la possibilità che le celle possano morire con probabilità associata al quadrato di $\gamma$, con l'evoluzione ad un modello $SIRD$ dove $D$ rappresenta i deceduti.\\ \\ Sulla base dei dati attuali (ultima settimana di agosto,\\ \textit{https://ourworldindata.org/mortality-risk-covid}), il tasso medio di mortalità nella popolazione mondiale è $\mu$ = 0,035, valore che confrontato con i valori consigliati delle variabili $\beta$ e $\gamma$ risulta essere mediamente il quadrato di $\gamma$: la scelta, perciò, di lasciare il tasso di mortalità come valore dipendente dal tasso di guarigione permette di avere una simulazione più realistica dell'epidemia per valori delle variabili fuori dall'intervallo consigliato. 
\\ \\


\section{Opzione 3}

\subsection{Spostamento}
L'opzione 2 Può essere facilmente estesa per simulare il movimento delle celle all'opzione 3. Fra un loop e l'altro di propagazione (\texttt{spread}) è possibile aggiungere una funzione che scambi di posizione un determinato numero di celle, per esempio \texttt{size}. Tutto ciò è possibile aggiungendo un metodo che scambi di posizione due celle specifiche avendone le coordinate ed una free function che generi casualmente 4 numeri all'interno della board, quindi non sui bordi. Le celle vengono scambiate salvando la posizione della prima in una variabile temporanea, assegnando alla prima il valore della seconda e infine assegnando il la variabile temporanea alla seconda. Tale modello matematico sfrutta il fatto che due punti presi a caso all'interno di un quadrato di lato $l$ abbiano distanza media $d \approx 0.52l$, simulando quindi uno spostamento di media lunghezza.\\
Avendo introdotto anche le celle $D$ è necessario controllare che nessuna delle due celle da scambiare sia morta, tale controllo viene effettuato dentro alla stessa funzione che genera le celle da scambiare, \texttt{cellMover}.\\ \\
Il modello di movimento può essere ulteriormente esteso aggiungendo dei filtri alla generazione dei numeri casuali, per esempio generando le posizioni delle celle da scambiare solamente in determinate regioni della board, per esempio solo nel quadrante superiore.\\
Il numero di celle in movimento preimpostato è il lato stesso della board. Tale numero è stato scelto perchè assicura contemporaneamente il poter osservare lo scoppio di nuovi focolai nelle opzioni \texttt{manual} e \texttt{auto} ma anche ottenere dei report aderenti al modello atteso. \\ \\
L'inizializzazione del movimento avviene dove avvengono le inizializzazioni di $\gamma$ e $\beta$, \texttt{checkParameters} infatti era stato costruito nell'ottica di aggiungere altri parametri di inizializzazione.\\
\subsection{Celle vuote}
L'estensione del programma ad una opzione 3 non sarebbe completa senza aggiungere alle celle la possibilità di essere vuote, simulando quindi uno spazio più grande all'interno del quale le celle possano spostarsi. Per fare ciò viene aggiunta l'opzione $E$ (Empty) alla \texttt{Enum}. Viene data all'utente la possibilità di scegliere la frazione di celle da svuotare. Tale parametro viene salvato assieme agli altri parametri inseriti dall'utente.\\
Nel codice la funzione che svuota le celle della \texttt{board} viene chiamata dopo l'inizializzazione degli infetti, è pertanto necessario che tale funzione non vada ad eliminare celle infette. Viene impostata quindi per eliminare solo celle suscettibili e non di bordo conn una generazione casuale simile a quella vista per l'inizializzazione degli infetti.\\
Se prima non era necessario assicurarsi che venisse selezionata casualmente più volte la stessa cella, visto che ai fini del propagarsi dell'epidemia conta solo che ci sia almeno un infetto, per l'eliminazione delle celle è necessario assicurarsi che il numero di eliminazioni sia quanto più possibile vicino a quello atteso dall'utente. Viene perciò inserito un contatore che tenga conto di quante volte l'operazione avviene con successo. Si definisce ora un ulteriore problema, ovvero che in situazioni estreme di popolazioni con molti malati iniziali e numerose eliminazioni (l'utente può giungere ad eliminare fino all'80\% delle celle) il programma continui a vuoto a tentare eliminazioni senza avere a disposizione ulteriori celle da eliminare, o comunque talmente poche che sia improbabile generarle casualmente. Come sorta di correttivo viene aggiunto un ulteriore contatore che tenga conto dei tentativi effettuati. Se tale numero raggiunge 100 volte il numero di celle da eliminare il programma termina l'eliminazione e procede alle fasi successive. Il numero 100 è stato scelto solo per l'estrema improbabilità che un buon input risulti in un numero così elevato di tentativi.\\

\section{Test}
I test del progetto sono avvenuti durante tutto il periodo di scrittura. In particolare i test hanno evidenziato in un primo momento l'errato funzionamento di alcune parti del codice fra cui il fatto che un prima bozza di \texttt{Spread()} andasse a interagire in maniera errata con la board, contagiando quasi tutta la popolazione già dal giorno 1. La funzione \texttt{emptyBoard()}, inutile nella versione finale ma comunque inserita come sicurezza in più è stata utile nella risoluzione di questo problema.\\
 Un altro errore che è stato riscontrato invece è stato il fatto che \texttt{cellMover} andasse a scambiare anche celle del bordo con celle della popolazione, aumentando il numero dei suscettibili durante l'epidemia.\\
 Il testing dei modelli di \texttt{spread} funzionanti è dovuto avvenire in maniera differente. Essendo la propagazione legata a dei numeri casuali l'assicurarsi del corretto funzionamento non può avvenire se non con un confronto dei report simulati con un modello atteso. Tale metodo non è estremamente rigoroso ma assicura che le propagazioni siano in linea coi valori di $\beta$ e $\gamma$
 
\section{Elaborazione dati}
 In seguito riportiamo le elaborazioni di alcune epidemie. Con $Size = 200$, $\beta = 0.1$, $\gamma = 0.15$:\\
 Come è possibile osservare la possibilità di spostamento favorisce l'aderenza della simulazione al modello $SIR$.\\
% TODO: \usepackage{graphicx} required
\begin{figure}[!h]
	\centering
	\includegraphics[width=0.8\linewidth]{swaplinear1}
	\caption[Lineare 1 con spostamento]{Lineare 1 con spostamento}
	\label{fig:swaplinear1}
\end{figure}
\begin{figure}[!h]
	\centering
	\includegraphics[width=0.8\linewidth]{swaplinear2}
	\caption[Lineare 2 con spostamento]{Lineare 2 con spostamento}
	\label{fig:swaplinear1}
\end{figure}
\begin{figure}[!h]
	\centering
	\includegraphics[width=0.8\linewidth]{swapnonlinear}
	\caption[nonLineare  con spostamento]{Non Lineare con spostamento}
	\label{fig:swaplinear1}
\end{figure}
\begin{figure}[!h]
	\centering
	\includegraphics[width=0.8\linewidth]{nonswapnonlinear}
	\caption[nonLineare noSpostamento]{Non Lineare senza spostamento}
	\label{fig:swaplinear1}
\end{figure}
\begin{figure}[!h]
	\centering
	\includegraphics[width=0.8\linewidth]{infectsnonlinearnonswap}
	\caption[Infetti nonLineare noSpostamento]{Infetti di Figura 4}
	\label{fig:swaplinear1}
\end{figure}

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.7\linewidth]{infectslinear2noswap}
	\caption[Infetti lineare 2 noSpostamento]{Infetti di Lineare 2, senza spostamento}
	
\end{figure}
\begin{figure}[!h]
	\centering
	\includegraphics[width=0.7\linewidth]{infectslinearswap}
	\caption[Infetti lineare 2 noSpostamento]{Infetti di opzione lineare 1 con spostamento}
	
\end{figure}




\end{document}
