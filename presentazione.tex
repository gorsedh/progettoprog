\documentclass[a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[main=italian, english]{babel}
\begin{document}
\title{Relazione Progetto Programmazione per la Fisica}
\author{Marco Caporale, Giacomo Giuliani, Massimiliano Stignani}
\date{Settembre 2020}
\maketitle

\section{Introduzione}
Questa relazione ha lo scopo di illustrare lo sviluppo del progetto per l'esame di Programmazione della Fisica dell'Anno Accademico 2019/2020. \\ \\ Il progetto è composto da un programma in linguaggio C++ che simuli lo sviluppo di un'epidemia su una griglia di stati. Il modello di sviluppo associato è un modello epidemico detto $SIR$, dove gli stati in gioco hanno uno sviluppo naturale, da S (suscettibili) divengono I (infetti) per poi diventere R (rimossi). \\ I passaggi da uno stato al successivo sono associati a
due probabilità, $\beta$ e $\gamma$, dove la prima è la probabilità di un suscettibile di infettarsi quando a contatto con un infetto, mentre la seconda è la probabilità di un infetto di diventare un rimosso. \\ 

\section{Opzione 1}
Lo sviluppo del progetto è iniziato attraverso la stesura di una  bozza dell'opzione 1, ovvero una stesura... %da completare%


\section{Opzione 2}
\subsection{Premessa}
La sezione principale del progetto si è svolta attorno alla creazione della seconda opzione, ovvero la creazione della simulazione epidemica attraverso una griglia di stati ispirata al celebre Game of Life di Conway ma invece che avere regole fisse per la riproduzione o la morte l'evoluzione della board è un processo legato alle probabilità fornite dall'utente: $\beta$ quella di infettarsi e $\gamma$ quella di guarire una volta infettata.\\ 
\subsection{Strutture}
Il fulcro del progetto sono le due variabili $\beta$ e $\gamma$, che sono state dichiarate globali per facilità di accesso delle altre funzioni del programma. Non essendo state dichiarate costanti sarà necessario aggiungere delle funzioni di controllo affinchè le variabili possano essere modificate all'occorrenza dalle funzioni per poi essere ristabilite ai valori originali stabiliti dall'utente.\\
A questo punto è necessario definire una enum che possa contenere le possibili condizioni degli individui in esame, ciò avviene in \texttt{Condition}, inizialmente contenente i simboli $S, I, R$.\\
Questi vengonno poi disposti nella classe \texttt{Population} a formare il vettore che rappresenti di fatto la popolazione in esame. Alla classe sono stati aggiunti alcuni metodi necessari successivamente alle funzioni del programma, fra questi i metodi di conta dei determinati stati assunti dalle celle. Al metodo di conta dei suscettibili vengono rimossi i soggetti sul bordo della griglia in quanto verranno considerati sempre come suscettibili ed impossibilitati a modificare il proprio stato di salute.\\
La rappresentazione grafica del sistema avviene tramite stampa da terminale. Questa ben si sposa con popolazioni di esigue dimensioni ma rischia di non essere efficace per grandi misure della board. Per questo motivo i dati verranno raccolti in un vettore che li stamperà su un file di testo per l'elaborazione grafica tramite software Root. Per tale fine è stato aggiunto \texttt{struct dailyReport} che contiene i dati raccolti dai metodi di \texttt{Population} alla fine di ogni giornata.\\
\subsection{Epidemia}
Il fulcro del programma consiste nell'effettivo spargersi dell'epidemia, motivo per cui sono necessarie le funzioni \texttt{adjacentInfects} e \texttt{spread}, la prima conta quanti infetti sono presenti nelle otto posizioni nelle celle adiacenti a quella in esame, la seconda invece prende in input la precedente popolazione per poi evolverla nella successiva. Il processo di base avviene generando tramite \texttt{uniform real distribution} un numero casualmente distribuito fra 0 e 1. Tale numero viene poi confrontato per ogni cella $Suscettibile$ con la probabilità di contagio, ovvero $\beta$ moltiplicato per il numero di infetti adiacenti alla cella e qualora fosse minore lo stato della cella verrebbe aggiornato ad $Infetta$. Tale relazione nasce dal considerare la probabilità di infezione come la retta passante per i punti $(0;0)$ e (1;$\beta$) nel piano cartesiano. Per le celle $Infette$ invece il numero viene più semplicemente confrontato con il $\gamma$. La funzione \texttt{spread} è stata in seguito soppressa per lasciare spazio alle due funzioni \texttt{linearSpread} e \texttt{nonLinearSpread}.\\ \\ \texttt{linearSpread} si propone due versioni, una che di fatto è la versione pura di \texttt{spread}, l'altra invece va a sostituire la retta di contagio precedentemente definita con la retta passante per (1;$\beta$) e (8,1). In questo modo la definizione di probabilità è più rispettata in quanto non può essere maggiore di 1. Onde evitare che tale valore possa essere maggiore di 1 per un valore nullo di \texttt{adjacentInfects} è stata introdotta la funzione \texttt{booleanMarker} che restituisce 0 quando le viene dato in input 0, altrimenti 1. Questo tipo di epidemia è stato lasciato commentato nel codice per sostituire all'occorrenza la sua versione più grezza ma che comunque produce risultati molto più vicini a quelli attesi del modello $SIR$.\\ \\
\texttt{nonLinearSpread} invece utilizza un approcio differente, in primo luogo aggiunge ai suoi parametri di input anche il tempo passato dall'inizio dell'epidemia, in questo modo può ad un determinato passaggio di tempo aumentare o ridurre all'occorrenza $\beta$ e $\gamma$, poi ristabilite dalla funzione di controllo. Un esempio applicativo potrebbe essere l'aumentare la contagiosità durante il sabato sera o aumentare i tassi di guarigione dopo ad un determinato tempo dall'inizio della simulazione. inoltre i valori da confrontare con i numeri generati casualmente sono moltiplicati per dei coefficienti che simulino parzialmente il fattore "Paura della malattia"\\ (\texttt{((beta*i)/(((size*size+previousDayInfects)/(size*size))))}),\\ che riduce la contagiosità all'aumentare del numero degli infetti sul totale.  \\
\subsection{Inizializzazioni}
La prima scelta lasciata all'utente aprendo il programma è che tipo di simulazione si voglia effettuare, potendo scegliere fra piccole popolazioni con output grafico o grandi popolazioni senza output grafico da terminale, ognuna delle precedenti opzioni è associata ad una rispettiva funzione di esecuzione \texttt{execute} e alle rispettive inizializzazioni.\\
Il programma lascia una discreta libertà di scelta all'utente, in particolare per quanto riguarda i due parametri  $\beta$ e $\gamma$ e la dimensione della popolazione da prendere in esame. Per ognuno di questi parametri sono presenti una o più funzioni di inizializzazione, per quanto riguarda le simulazioni con output grafico la dimensione della popolazione è limitata poichè oltre una determinata soglia la stampa da terminale diventa disordinata e quindi inutile. Viceversa l'opzione per grandi popolazioni è limitata esclusivamente alle prestazioni del pc che esegue il programma, si possono infatti eseguire in tempi ragionevoli simulazioni anche su popolazioni dell'ordine del milione.\\
Sono inoltre presenti differenti inizializzazioni per il numero iniziale di infetti delle grandi popolazioni, in particolare la possibilità di partire da un solo infetto randomicamente disposto nella griglia, 10 infetti disposti in una porzione ridotta di griglia o un numero di malati scelto dall'utente. Per le piccole popolazioni è stato scelto di lasciare un solo tipo di inizializzazione degli infetti ovvero quello di infettare solamente il soggetto in (1;1). Tale decisione è stata scelta fondamentalmente per due motivi, il primo è l'alta improbabilità che più soggetti importino il morbo dall'esterno in una popolazione ridotta, la seconda invece è la maggior apprezzabilità dell'output grafico vedendo l'epidemia partire da un solo angolo per poter poi diffondersi lungo tutta la griglia. \\
\subsection{Elaborazione dati e Grafica}
L'output grafico con stampa a terminale del programma è disponibile solo per le piccole popolazioni tramite la funzione \texttt{gridPrint}. Ad ogni stato è associata una determinata lettera con un differente colore per facilitare la lettura durante la stampa. \\
Sia che si utilizzi l'output grafico del terminale o no alla fine dell'epidemia (ovvero quando il numero degli infetti scende a zero) il programma chiederà all'utente se vuole la stampa su file di testo (\texttt{.txt}) del report dell'epidemia, ovvero la conta giornaliera degli stati della popolazione. Tale report può essere graficato tramite l'uso del software di analisi dati Root. Assicurandosi che il file si trovi nella stessa directory da cui si esegue la macro è possibile stampare i grafici con i singoli andamenti di ognuno degli stati possibili (\texttt{graphS()}, \texttt{graphI()}, \texttt{graphD()}) oppure di stampa di tutti e tre gli andamenti su un unico grafico (\texttt{graphEpidemic()}). Utilizzando \texttt{graphAll()} si possono stampare tutti igrafici contemporaneamente.
\subsection{Estensione del modello $SIR$}
A questo punto del progetto è stato esteso il modello $SIR$ per includere anche la possibilità che le celle possano morire con probabilità associata al quadrato di $\gamma$, di fatto spostandosi verso ad un modello $SIRD$ dove $D$ rappresenta i deceduti.\\ \\
Giustificazioni della scelta del quadrato...\\ \\


\section{Opzione 3}
L'opzione 2 Può essere facilmente estesa per simulare il movimento delle celle. Fra un loop e l'altro di propagazione (\texttt{spread}) è possibile aggiungere una funzione che scambi di posizione un determinato numero di celle, per esempio \texttt{size}. Tutto ciò è possibile aggiungendo un metodo che scambi di posizione due celle specifiche avendone le coordinate ed una free function che generi casualmente 4 numeri all'interno della board, quindi non sui bordi. Le celle vengono scambiate salvando la posizione della prima in una variabile temporanea, assegnando alla prima il valore della seconda e infine assegnando il la variabile temporanea alla seconda. Tale modello matematico sfrutta il fatto che due punti presi a caso all'interno di un quadrato di lato $l$ abbiano distanza media $d \approx 0.52l$, simulando quindi uno spostamento di media lunghezza.\\
Avendo introdotto anche le celle $D$ è necessario controllare che nessuna delle due celle da scambiare sia morta, tale controllo viene effettuato dentro alla stessa funzione che genera le celle da scambiare, \texttt{cellMover}.\\ \\
Il modello di movimento può essere ulteriormente esteso aggiungendo dei filtri alla generazione dei numeri casuali, per esempio generando le posizioni delle celle da scambiare solamente in determinate regioni della board, per esempio solo nel quadrante superiore.\\

\section{Requisiti}
Il programma non richiede particolari requisiti, in particolare per le opzioni con stampa a terminale. \`E comunque necessario assicurarsi che siano disponibili i caratteri colorati per la stampa dal proprio terminale (UBUNTU/Linux e Mac Os), nel caso non venissero caricati è sufficiente chiudere e riaprire il terminale.\\
Le istruzioni compaiono a schermo.\\
Per eseguire l'analisi grafica dell'epidemia è necessario il software di analisi dati Root, disponibile su \texttt{root.cern}.
Al termine del programma verrà chiesto se salvare il report dell'epidemia come \textttt{report.txt}. Inserendo questo file nella stessa directory di macro.c ed eseguirvi Root, chiamando prima \texttt{.L macro.c} e poi la funzione desiderata di stampa (opzioni disponibili elencate nella sottosezione Elaborazione dati e Grafica).



\end{document}
