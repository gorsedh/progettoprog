\documentclass[a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[main=italian, english]{babel}
\begin{document}
\title{Relazione Progetto Programmazione per la Fisica}
\author{Marco Caporale, Giacomo Giuliani, Massimiliano Stignani}
\date{Settembre 2020}
\maketitle

\section{Introduzione}
Questa relazione ha lo scopo di illustrare lo sviluppo del progetto per l'esame di Programmazione della Fisica dell'Anno Accademico 2019/2020. \\ \\ Il progetto è composto da un programma in linguaggio C++ che simuli lo sviluppo di un'epidemia su una griglia di stati. Il modello di sviluppo associato è il cosiddetto $SIR$, nel quale gli stati di salute delle persone in esame hanno uno sviluppo naturale, inizialmente sono \underline{suscettibili} (S), quindi \underline{infetti} (I), infine \underline{rimossi} (R), categoria che comprende indifferentemente i soggetti guariti e i morti. \\ I passaggi da uno stato al successivo sono associati a due valori di probabilità, $\beta$, la probabilità di un suscettibile di essere infettato quando a contatto con un infetto e $\gamma$, la probabilità di un infetto di diventare un rimosso. \\ 

\section{Opzione 1}
Lo sviluppo del progetto è iniziato attraverso la stesura di una  bozza dell'opzione 1, ovvero una stesura molto approssimativa di un'evoluzione lineare della pandemia nel tempo - il codice di tale sviluppo non verrà consegnato con la relazione, ma verranno utilizzati i risultati di quest'ultimo come confronto teorico con il modello principale. 
Per tale modello, è stata definita una \texttt{struct State} che racchiude solo i 3 stati possibili,$S, I, R$, definiti come \texttt{int}, associata a questa, è stato definito un operatore di uguaglianza da poter utilizzare nella funzione di evoluzione \texttt{bool operator==(State const& lhs, State const& rhs) {
		if((lhs.s == rhs.s) && (lhs.i == rhs.i) && (lhs.r == rhs.r)) { return true;}
		else { return false;}
	}}. \\ \\ Quindi, viene definita minimalmente una \texttt{class Epidemic} utile a definire il decorso dell'epidemia, nella quale viene definita la funzione Evolve, che simula il decorso di S(t), I(t), R(t) sfruttando le equazioni del modello $SIR$ a partire da uno stato iniziale, \texttt{state s0}, definito nella parte \texttt{private}. \\ \\ Per quanto riguarda la funzione di stampa, viene implementata la funzione \texttt{void printData(std::vector<State> report) {}} che opera sia una stampa da terminale sia una raccolta dati su un file di testo, poi elaborati graficamente sul software root, elaborazione che sarà presentata in seguito come confronto con i risultati ottenuti dal modello successivamente presentato.  


\section{Opzione 2}
\subsection{Premessa}
La parte principale del progetto è stata dedicata al secondo progetto possibile, ovvero lo sviluppo di una simulazione epidemica attraverso una griglia di stati ispirata al celebre Game of Life di Conway;la differenza principale tra il G.O.L. e la simuazione epidemica risiede nell'evoluzione della board: se, infatti, nel primo caso lo sviluppo della board è definito tramite alcune semplici condizioni, nel secondo caso il processo dipende da 2 probabilità: $\beta$ quella di infettarsi e $\gamma$ quella di guarire se infetti, inserite a scelta dall'utente.\\ 
\subsection{Strutture}
Il cuore del progetto sono le due variabili $\beta$ e $\gamma$, dichiarate \textit{globali} per facilità di accesso delle altre funzioni del programma. Per questo motivo, è stato necessario implementare delle funzioni di controllo in modo tale che le variabili, quando modificate dalle funzioni  del programma, vengano ristabilite ai valori originali inseriti dall'utente.\\
Quindi è necessario definire una \texttt{enum Condition} che possa contenere i possibili stati di salute degli individui in esame, $S, I, R$ rispettivamente suscettibili, infetti, rimossi.\\
Questi vengono poi disposti nella \texttt{class Population} a formare il vettore che rappresenti la popolazione in esame. Alla classe sono stati aggiunti alcuni metodi necessari alle altre funzioni del programma, fra questi i metodi di conta dei determinati stati assunti dalle celle. Al metodo di conta dei suscettibili vengono rimossi i soggetti sul bordo della griglia, in quanto vengono definniti di defalt come suscettibili, perciò impossibilitati a modificare il proprio stato di salute.\\
La rappresentazione grafica del sistema avviene tramite stampa da terminale. Questa risulta efficiente con popolazioni di esigue dimensioni ma rischia di non esserlo per grandi misure della board. Per questo motivo i dati vengono raccolti in un vettore che li stampa su un file di testo \texttt{std::vector<dailyReport> finalReport} per l'elaborazione grafica tramite software Root. Per tale fine è stato aggiunto \texttt{struct dailyReport} che contiene i dati raccolti dai metodi di \texttt{Population} alla fine di ogni giornata.\\
\subsection{Epidemia}
Il fulcro del programma consiste nell'effettiva diffusione dell'epidemia lungo la griglia, motivo per cui sono necessarie le funzioni \texttt{adjacentInfects} e \texttt{spread}: la prima conta quanti infetti sono presenti nelle otto celle adiacenti a quella in esame, la seconda, invece, prende in input la precedente popolazione per poi evolverla nella successiva. Il processo di base avviene generando tramite \texttt{uniform real distribution} un numero casualmente distribuito fra 0 e 1. Tale numero viene poi confrontato per ogni cella $Suscettibile$ con la probabilità di contagio, ovvero $\beta$ moltiplicato per il numero di infetti adiacenti alla cella e qualora fosse minore lo stato della cella verrebbe aggiornato ad $Infetta$. Tale relazione nasce dal considerare la probabilità di infezione come la retta passante per i punti $(0;0)$ e (1;$\beta$) nel piano cartesiano. Per le celle $Infette$ invece il numero viene più semplicemente confrontato con il $\gamma$. La funzione \texttt{spread} è stata in seguito soppressa per lasciare spazio alle due funzioni \texttt{linearSpread} e \texttt{nonLinearSpread}.\\ \\ \texttt{linearSpread} viene proposta due versioni, la prima, come versione pura di \texttt{spread}, la seconda, invece, va a sostituire la retta di contagio precedentemente definita con la retta passante per (1;$\beta$) e (8,1).Onde evitare che il valore della probabilitàdi contagio possa essere maggiore di 1 per un valore nullo di \texttt{adjacentInfects} è stata introdotta la funzione \texttt{booleanMarker} che restituisce 0 quando le viene dato in input 0, altrimenti 1. Questo secondo modello è stato lasciato commentato nel codice dal momento che la sua versione più "grezza", la versione pura di \texttt{linearSpread}, produce risultati molto più vicini a quelli attesi del modello $SIR$.\\ \\
Il modello basato sulla funzione \texttt{nonLinearSpread} utilizzainvece un approcio differente, in primo luogo aggiungendo ai suoi parametri di input anche il tempo passato dall'inizio dell'epidemia \texttt{int daysPassed}, in questo modo, per determinati intervalli di tempo, si possono modificare le variabili $\beta$ e $\gamma$, poi ristabilite dalla funzione di controllo. Esempi applicativi presenti nel progetto sono: la simulazione delle maggiori relazioni interpersonali nei weekend \texttt{if (daysPassed \% 7 == 0) { beta = beta * 1.5; }}, per cui è lecito ipotizzare un aumento del tasso di contagio; inoltre, si è scelto di seguire un modello "svedese", senza quindi simulare eventuali misure particolarmente restrittive, come una quarantena, a favore di uno sviluppo di metodi curativi e un conseguente aumento del tasso di guarigione $\gamma$ - 
\texttt{if (daysPassed > 60 && daysPassed <= 100) { gamma_ = gamma_ * 1.5; }
if (daysPassed > 101) { gamma_ = gamma_ * 2; }}.
\subsection{Inizializzazioni}
La prima scelta lasciata all'utente aprendo il programma è quale tipo di simulazione si voglia effettuare, piccole popolazioni con output grafico o grandi popolazioni senza output grafico da terminale; ognuna delle precedenti opzioni è associata ad una rispettiva funzione di esecuzione \texttt{execute} e alle rispettive inizializzazioni.\\
Il programma lascia una discreta libertà di scelta all'utente, in particolare per quanto riguarda le due variabili  $\beta$ e $\gamma$ e la dimensione della popolazione da prendere in esame, attraverso la scelta della grandezza della griglia. Per ognuno di questi parametri sono presenti una o più funzioni di inizializzazione; per quanto riguarda le simulazioni con output grafico la dimensione della popolazione è limitata poichè oltre una determinata soglia la stampa da terminale diventa disordinata e quindi inutile. Viceversa l'opzione per grandi popolazioni è limitata esclusivamente alle prestazioni del pc che esegue il programma, si possono infatti eseguire in tempi ragionevoli simulazioni anche su popolazioni dell'ordine del milione.\\
Sono inoltre presenti differenti inizializzazioni per il numero iniziale di infetti delle grandi popolazioni, in particolare la possibilità di partire da un solo infetto casualmente disposto nella griglia, 10 infetti disposti in una porzione ridotta di griglia o un numero di malati scelto dall'utente. Per le piccole popolazioni è stato scelto di lasciare un solo tipo di inizializzazione degli infetti ovvero quello di infettare solamente il soggetto in (1;1). Tale decisione dipende fondamentalmente da due motivi, il primo è l'alta improbabilità che più soggetti importino il morbo dall'esterno in una popolazione ridotta, la seconda invece è la maggior apprezzabilità dell'output grafico vedendo l'epidemia partire da un solo angolo per poter poi diffondersi lungo tutta la griglia. \\
\subsection{Elaborazione dati e Grafica}
L'output grafico con stampa a terminale del programma è disponibile solo per le piccole popolazioni tramite la funzione \texttt{gridPrint}. Ad ogni stato è associata una determinata lettera con un differente colore per facilitare la lettura durante la stampa. \\
Sia che si utilizzi l'output grafico del terminale o no alla fine dell'epidemia (ovvero quando il numero degli infetti scende a zero) il programma chiederà all'utente se vuole la stampa su file di testo (\texttt{.txt}) del report dell'epidemia, ovvero la conta giornaliera degli stati della popolazione. Tale report può essere graficato tramite l'uso del software di analisi dati Root. Assicurandosi che il file si trovi nella stessa directory da cui si esegue la macro è possibile stampare i grafici con i singoli andamenti di ognuno degli stati possibili (\texttt{graphS()}, \texttt{graphI()}, \texttt{graphD()}) oppure di stampa di tutti e tre gli andamenti su un unico grafico (\texttt{graphEpidemic()}). Utilizzando \texttt{graphAll()} si possono stampare tutti igrafici contemporaneamente.
\subsection{Estensione del modello $SIR$}
Terminata la "parte canonica" del progetto, il modello $SIR$ per includere anche la possibilità che le celle possano morire con probabilità associata al quadrato di $\gamma$, con l'evoluzione ad un modello $SIRD$ dove $D$ rappresenta i deceduti.\\ \\ Sulla base dei dati attuali (ultima settimana di agosto, \textit{https://ourworldindata.org/mortality-risk-covid}), il tasso medio di mortalità nella popolazione mondiale è $\mu$ = 0,035, valore che confrontato con i valori consigliati delle variabili $\beta$ e $\gamma$ risulta essere mediamente il quadrato di $\gamma$: la scelta, perciò, di lasciare il tasso di mortalità come valore dipendente dal tasso di guarigione permette di avere una simulazione più realistica dell'epidemia per valori delle variabili fuori dall'intervallo consigliato. 
\\ \\


\section{Opzione 3}
L'opzione 2 Può essere facilmente estesa per simulare il movimento delle celle all'opzione 3. Fra un loop e l'altro di propagazione (\texttt{spread}) è possibile aggiungere una funzione che scambi di posizione un determinato numero di celle, per esempio \texttt{size}. Tutto ciò è possibile aggiungendo un metodo che scambi di posizione due celle specifiche avendone le coordinate ed una free function che generi casualmente 4 numeri all'interno della board, quindi non sui bordi. Le celle vengono scambiate salvando la posizione della prima in una variabile temporanea, assegnando alla prima il valore della seconda e infine assegnando il la variabile temporanea alla seconda. Tale modello matematico sfrutta il fatto che due punti presi a caso all'interno di un quadrato di lato $l$ abbiano distanza media $d \approx 0.52l$, simulando quindi uno spostamento di media lunghezza.\\
Avendo introdotto anche le celle $D$ è necessario controllare che nessuna delle due celle da scambiare sia morta, tale controllo viene effettuato dentro alla stessa funzione che genera le celle da scambiare, \texttt{cellMover}.\\ \\
Il modello di movimento può essere ulteriormente esteso aggiungendo dei filtri alla generazione dei numeri casuali, per esempio generando le posizioni delle celle da scambiare solamente in determinate regioni della board, per esempio solo nel quadrante superiore.\\

\section{Requisiti}
Il programma non richiede particolari requisiti, in particolare per le opzioni con stampa a terminale. \`E comunque necessario assicurarsi che siano disponibili i caratteri colorati per la stampa dal proprio terminale (UBUNTU/Linux e Mac Os), nel caso non venissero caricati è sufficiente chiudere e riaprire il terminale.\\
Le istruzioni compaiono a schermo.\\
Per eseguire l'analisi grafica dell'epidemia è necessario il software di analisi dati Root, disponibile su \texttt{root.cern}.
Al termine del programma verrà chiesto se salvare il report dell'epidemia come \textttt{report.txt}. Inserire questo file nella stessa directory di macro.c ed eseguirvi Root, chiamando prima \texttt{.L macro.c} e poi la funzione desiderata di stampa (opzioni disponibili elencate nella sottosezione Elaborazione dati e Grafica).



\end{document}
